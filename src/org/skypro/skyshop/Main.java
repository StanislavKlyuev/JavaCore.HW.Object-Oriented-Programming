package org.skypro.skyshop;

public class Main {

        /*
ЗАДАЧА 1. Введение в ООП. Инкапсуляция

        Что нужно сделать
        Ваша задача — создать структуру классов для интернет-магазина. Над этой структурой вы будете работать еще в
        нескольких домашках, поэтому сохраните этот проект.
                * Создайте обычное Java-приложение с одним классом  App  и методом main().
                * Сделайте коммит в ветку main(master).
                * После этого создайте новую ветку и выполните в ней домашнее задание.

        Описание структуры
        Пока наш интернет-магазин будет содержать только классы товаров и корзины для товаров. Эти классы нужно создать
        с учетом принципа инкапсуляции и разнести по пакетам.

        Создание корневого пакета
        1.	Создайте в папке src пакет с названием org.skypro.skyshop. Этот пакет будет корневым для всех остальных пакетов
            в нашем приложении.
        2.	Перенесите в этот пакет класс App с методом main. Его нужно обязательно перенести, а не копировать. Для переноса
            можно использовать Drag and Drop или комбинацию клавиш «Вырезать»/«Вставить».

        Для последующих домашних заданий этого курса вам нужно создавать корневой пакет, иначе работа не будет принята.

        Создание класса товара
        Создайте в пакете org.skypro.skyshop.product класс товара Product, который будет содержать два значения:
            * название продукта в виде строки,
            * стоимость продукта в виде целого числа.
        Эти значения должны быть немодифицируемыми после создания объекта, но должна быть возможность получить эти
        значения в других классах.

        Подсказка
        Если значения должны быть немодифицируемыми — это значит, что в нашем классе должен быть единственный конструктор,
        принимающий эти значения. Сами поля должны иметь модификатор private, а доступ к ним должен осуществляться с помощью геттеров.

        Создание класса корзины для товаров
        Создайте простой класс корзины ProductBasket в пакете org.skypro.skyshop.basket.
        Этот класс содержит в себе одну корзину с продуктами, которые купил один пользователь. Вам нужно реализовать следующие публичные методы:
            * Метод добавления продукта в корзину: метод принимает в себя продукт и ничего не возвращает.
            * Метод получения общей стоимости корзины: метод ничего не принимает и возвращает целое число.
            * Метод, который печатает содержимое корзины: метод ничего не принимает и не возвращает, но печатает в консоль сообщение вида:
                <имя продукта>: <стоимость>
                <имя продукта>: <стоимость>
                <имя продукта>: <стоимость>
                Итого: <общая стоимость корзины>
        Если в корзине ничего нет, нужно напечатать фразу «в корзине пусто».
            * Метод, проверяющий продукт в корзине по имени: метод принимает в себя строку имени и возвращает Boolean
              в зависимости от того, есть продукт в корзине или его нет.
            * Метод очистки корзины: метод ничего не принимает и очищает массив, проставляя всем его элементам null.

        Обратите внимание!
            1. В качестве хранилища для объектов product используйте массив из пяти элементов, однако прямой доступ
               к этому массиву должен быть невозможен.
            2. Если в массиве не хватает места на следующий продукт, то метод добавления продукта должен выводить
               в консоль сообщение вида: «Невозможно добавить продукт».

        Демонстрация классов
        Создайте в классе App в методе main несколько продуктов и продемонстрируйте работу всех методов корзины по следующему сценарию:
            1. Добавление продукта в корзину.
            2. Добавление продукта в заполненную корзину, в которой нет свободного места.
            3. Печать содержимого корзины с несколькими товарами.
            4. Получение стоимости корзины с несколькими товарами.
            5. Поиск товара, который есть в корзине.
            6. Поиск товара, которого нет в корзине.
            7. Очистка корзины.
            8. Печать содержимого пустой корзины.
            9. Получение стоимости пустой корзины.
            10. Поиск товара по имени в пустой корзине.

        Рекомендации по выполнению работы
            1. Используйте модификатор static только в методе main, а модификатор public — только для методов и конструкторов.
            2. Для демонстрации классов можно создать несколько корзин.

ЗАДАЧА  2. ООП: наследование, абстрактные классы

                Описание структуры
        Интернет-магазин начинает поддерживать новые типы товаров, а значит, нужно расширить модель классов,
        чтобы поддерживать эти типы. Для этого:
            •	создадим классы для товаров со скидкой и товаров с фиксированной ценой,
            •	поменяем вывод данных в корзине,
            •	добавим новые методы для товаров и корзины.

        Выполняйте задание строго по порядку. Пока не сделали предыдущий шаг — не приступайте к следующему.

        1. Выделение корня иерархии
        Чтобы поддерживать новые типы товаров, нужно создать иерархию наследования для них.
            •	Сделайте класс Product  абстрактным и уберите из него поле цены.
            •	Так как цены у нас нет, метод getPrice() тоже должен стать абстрактным.
            •	Класс Product станет новым корнем иерархии, от него будем наследовать специфические классы товаров.

        Обратите внимание!
        После этого шага проект не будет компилироваться и запускаться. Так как в методе main класса App мы создаем
        товары через оператор new, а абстрактные классы создавать через оператор new нельзя.

        2. Создание класса обычного товара
            •	Восстановите функциональность кода: сделайте класс SimpleProduct, который наследуется от Product
                и принимает в свой конструктор (кроме имени) обычную цену товара, а переопределенный метод
                getPrice возвращает эту цену.
            •	Когда вы замените классом SimpleProduct класс Product в методе main, то получите полностью рабочий проект,
                в котором работает демонстрация.

        Обратите внимание! Класс корзины на этом этапе менять нельзя, и это не должно потребоваться.
        Если класс корзины не компилируется или какие-то методы в нем показывают ошибку, это значит, что вы
        неправильно выделили абстрактный класс или пропустили какой-то шаг.

        3. Создание класса товара со скидкой
            •	Расширим иерархию классов. Для этого сделайте класс товара со скидкой DiscountedProduct.
                Этот класс нужно унаследовать от Product.
            •	В этом классе создайте два поля — «базовая цена» и «скидка в целых процентах».
                Скидка может быть только положительным целым числом от 0 до 100. Проверку на это не нужно делать,
                достаточно просто учитывать при написании методов.
            •	Переопределите метод getPrice так, чтобы он учитывал скидку, которую вы применили к товару.

        4. Создание класса товара с фиксированной ценой
        В нашем интернет-магазине есть типы товаров с фиксированной ценой — fix price.
        Цена назначается один раз в год, поэтому в данный момент ее выгоднее установить в коде, используя константу.
            •	Создайте класс FixPriceProduct, конструктор которого принимает только имя продукта,
                а метод getPrice возвращает некоторую фиксированную цену.
            •	Саму фиксированную цену нужно оформить в виде приватной константы в классе FixPriceProduct.

        Константы в Java — это static- и final-переменные в классе. Имена констант используют специальный вид
        написания под названием SCREAMING_SNAKE_CASE.
        Если какое-то значение постоянно повторяется в программе, вы можете сохранить его в константе и использовать
        константу вместо непосредственного значения.

                // Пример объявления константы
                private static final String USER_GREETING = "Hello user!";

                // Пример константы в классе java.lang.Math, она выделена для понимания,
                // что последовательность цифр 3.14159265358979323846 — это число пи
                public static final double PI = 3.14159265358979323846;

        5. Изменение вывода корзины в классе ProductBacket
            •	Измените метод вывода, который печатает содержимое корзины, чтобы результат выводился в следующем виде:

                <имя продукта>: <стоимость>
                <имя продукта со скидкой>: <стоимость> (<скидка>%)
                <имя продукта c фиксированной ценой>: Фиксированная цена <значение константы фиксированной цены>
                Итого: <общая стоимость корзины>
                Специальных товаров: <Количество специальных товаров>
                Специальный товар — это товар со скидкой или фиксированной стоимостью.

        Чтобы правильно написать данный метод, вам нужно:
            •	переопределить метод toString в классах товаров так, чтобы вызов toString у товара выводил строку
                нужного формата (как на примере выше).

        Для подсчета количества специальных товаров:
            •	добавьте в абстрактный класс товара метод isSpecial, который возвращает true или false и
                переопределяет его в других классах товаров.

        Обратите внимание! В этом задании нельзя использовать оператор instanceof или другие методы,
        которые определяют класс товара. Используйте переопределение методов или вводите новые методы.

        6. Проверка изменений
            1.	Создайте в методе main несколько товаров специальных типов вместо SimpleProduct.
            2.	Проверьте, что все методы выводят правильные значения.
            3.	Убедитесь, что метод печати содержимого корзины выводит результат в нужной форме.

ЗАДАЧА  3. ООП: полиморфизм, интерфейсы

        Что нужно будет сделать
        В этой домашней работе мы добавим в приложение интернет-магазина новую сущность и сделаем движок для поиска по товарам.

        Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашку. За основу возьмите результат вашей работы по наследованию.

        1. Создание новой сущности
        Наш интернет-магазин растет, и мы решили добавить в объектную модель статьи о товарах.
        Для этого создайте класс Article, который будет немодифицируемым, как и класс товара, и будет содержать такой набор полей:
            •	название статьи в виде строки,
            •	текст статьи в виде строки.

        Добавьте в класс метод toString, который будет преобразовывать статью в строку такого вида:
            Название статьи
            Текст статьи

        Подсказка
        Класс нужно определить в один из существующих пакетов или создать новый. Подумайте, какой вариант лучше подойдет для этой задачи.

        2. Добавление функциональности поиска
        Чтобы была возможность искать и по статьям, и по товарам, нам нужно объединить их по какому-то признаку.
        Общий родительский класс тут не очень подходит, поэтому для реализации поиска понадобится интерфейс, который будет реализовывать статьи и товары.
            1.	Создайте интерфейс Searchable, который будет иметь три метода:
                •	Метод получения search term (термина поиска) — метод, который будет возвращать текст, по которому мы будем искать.
                •	Метод получения типа контента, который мы нашли. Метод должен возвращать строку с названием типа контента.
                •	Метод получения имени Searchable-объекта.

        Метод преобразования Searchable-объекта в строку (он не может называться toString, так как toString мы используем
        для вывода товаров в корзине) лучше назвать getStringRepresentation(). Стоит сделать этот метод интерфейса default
        и добавить реализацию, которая будет выводить строку вида: «имя Searchable-объекта — тип Searchable-объекта».
        Также не забывайте про правильный пакет.
            2.	Реализуйте интерфейс Searchable в классах товаров и статей. Для этого:
                •	В классе товаров нужно имплементировать интерфейс Searchable в родительском классе товаров и в
                    качестве search term — «возвращать имя товара», а в качестве типа — возвращать строку PRODUCT.
                •	В классе статьи в качестве search term нужно вернуть строку, состоящую из названия и текста статьи.
                    Можно просто возвращать строку из toString, в качестве типа возвращаем строку ARTICLE.

        3. Добавление компонента поиска
        Теперь у нас есть классы, поддерживающие поиск. Нам нужен класс, который будет искать введенную строку среди
        наших товаров и статей и показывать максимум 5 подходящих результатов пользователю.
        Для этого реализуйте класс SearchEngine, который состоит из следующих элементов.
            1.	Поле Searchable[] — массив всех элементов, по которым можно искать. Размерность массива нужно передавать через конструктор класса SearchEngine
            2.	Метод search — принимает в себя строку для поиска и возвращает 5 результатов поиска по массиву Searchable в виде массива из 5 элементов.
            3.	Метод add() — добавляет новый объект типа Searchable в массив поискового движка.

        Обратите внимание! Чтобы реализовать поиск по массиву Searchable, нужно перебрать весь массив: брать у каждого
        элемента SearchTerm и искать по нему, используя встроенный метод строки contains. Найденные элементы нужно сразу определять в массив.

        Если элементов больше 5, то можно прерывать цикл поиска с помощью ключевого слова break. Массив результатов может
        содержать null-элементы, а также его не нужно сортировать или вставлять элементы специальным образом через индексы,
        достаточно вернуть 5 первых подходящих объектов Searchable

        4. Тестирование изменений
        Теперь нам нужно продемонстрировать и протестировать изменения. Для этого:
            •	Создайте один объект типа SearchEngine  и добавьте в него все товары, которые создаются для проверки других методов.
            •	Создайте несколько объектов типа Article и добавьте их в Search Engine.
            •	Продемонстрируйте функциональность поиска с помощью объекта SearchEngine: вызовите метод search несколько раз с разными строками поиска.

        Подсказка
        Найденные объекты можно выводить с помощью System.out.println и статического метода класса Arrays → Arrays.toString(arr).

ЗАДАЧА  4. ООП: Исключения в Java

        Что нужно сделать
        В этой домашней работе вы продолжите работу над проектом интернет-магазина. На этот раз вам нужно будет:
            •	реализовать проверки полей для создания товаров и статей, чтобы не было возможности создавать неправильные объекты,
            •	расширить функциональность поиска по товарам и статьям.

        Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу.

        1. Реализация проверок в конструкторе класса Product
        Так как все классы наших продуктов унаследованы от Product, мы можем реализовать проверку данных только в нем.
        В конструкторе класса Product реализуйте проверку названия по следующим условиям:
            1.	Название продукта не может быть пустой строкой или null. При этом пустая строка может быть также строкой,
            состоящей только из пробелов: в этом случае правило не выполняется, так как это неправильное название для продукта.

        Подсказка
        Чтобы проверить, что строка не пустая и не состоит только из пробельных символов, можно использовать метод isBlank() класса String.

            2.	В конструкторе класса SimpleProduct реализуйте проверку передаваемой цены продукта, цена должна быть строго больше 0.
                Слово «строго» означает, что цена не включает в себя ноль, то есть должна быть 1 или выше.
            3.	В конструкторе класса DiscountedProduct реализуйте проверки базовой цены и процента скидки. Правила для базовой цены —
                такие же, как для цены в классе SimpleProduct. Правила для процента скидки — процент должен быть числом в
                диапазоне от 0 до 100 включительно. Слово «включительно» означает, что границы диапазона 0 и 100 тоже являются правильными значениями.

        Проверки по этим условиям нужно добавить в конструкторы классов. Если условия не выполняются, вам нужно выбросить
        IllegalArgumentException с сообщением, в котором раскрыты детали о том, какое правило не сработало.

        2. Демонстрация проверки данных в классе main
            •	Создайте несколько продуктов и нарочно заполните их поля неправильно.
            •	Затем обработайте IllegalArgumentException в блоках try и catch.
            •	В качестве обработки можно просто выводить сообщение из исключения.

        3. Реализация метода поиска самого подходящего элемента
            •	Реализуйте в классе SearchEngine метод, который находит среди объектов Searchable наиболее подходящий к поисковой строке и возвращает его.
            •	Метод должен принимать строку search, а возвращать объект Searchable.
        Наиболее подходящим назовем объект типа Searchable. Его метод getSearchTerm() содержит максимальное количество повторов строки search.
        Если таких объектов несколько, то вернуть можно любой из них.

        Подсказка
        Чтобы найти максимальное количество повторений подстроки в строке, можно воспользоваться следующим алгоритмом.
            //Алгоритм написан псевдокодом, и его идея в том, чтобы, используя операцию поиска индекса подстроки в строке посчитать количество
            //Операция indexOf(substring, индекс) ищет первый подходящий индекс подстроки, начиная с индекса "индекс".
            //Если она находит что-то, то индекс перемещается на длину подстроки и операция повторяется
            //до тех пора, пока в оставшей строке нет больше вхождений нашей подстроки
                str = "helloabcdehellonnnnnnhello"
                substring = "hello"
                количество = 0
                индекс = 0
                индексПодстроки = str.indexOf(substring, индекс)

            while(индексПодстроки != -1){
                количество++;
                индекс = индексПодстроки + substring.length();
	            индексПодстроки = str.indexOf(substring, индекс)
            }

        4. Добавление исключений
        Мы не хотим, чтобы метод поиска наиболее подходящего объекта возвращал null, если такого объекта нет.
        Поэтому если объект не найден, вам нужно выбрасывать собственное исключение — назовите его BestResultNotFound.
        Это исключение должно быть проверяемым, и в сообщении должно содержать информацию, для какого поискового запроса не нашлось подходящей статьи.

        5. Демонстрация нового метода поиска
        Продемонстрируйте в методе main новый метод поиска в двух сценариях:
            •	когда нужный объект существует,
            •	когда метод выбрасывает исключение.
        Обработайте исключение и выведите сообщения об ошибке.



ЗАДАЧА  5. ООП: Java Collections Framework: List

ЗАДАЧА  6. ООП: Java Collections Framework: Map

ЗАДАЧА  7. ООП: Java Collections Framework: Set

ЗАДАЧА  8. ООП: Stream API и лямбда-выражения


*/
}