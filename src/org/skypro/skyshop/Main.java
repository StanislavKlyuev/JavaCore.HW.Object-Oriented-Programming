package org.skypro.skyshop;

public class Main {
/*
ЗАДАЧА 1. Введение в ООП. Инкапсуляция

        Что нужно сделать
        Ваша задача — создать структуру классов для интернет-магазина. Над этой структурой вы будете работать еще в
        нескольких домашках, поэтому сохраните этот проект.
                * Создайте обычное Java-приложение с одним классом  App  и методом main().
                * Сделайте коммит в ветку main(master).
                * После этого создайте новую ветку и выполните в ней домашнее задание.

        Описание структуры
        Пока наш интернет-магазин будет содержать только классы товаров и корзины для товаров. Эти классы нужно создать
        с учетом принципа инкапсуляции и разнести по пакетам.

        Создание корневого пакета
        1.	Создайте в папке src пакет с названием org.skypro.skyshop. Этот пакет будет корневым для всех остальных пакетов
            в нашем приложении.
        2.	Перенесите в этот пакет класс App с методом main. Его нужно обязательно перенести, а не копировать. Для переноса
            можно использовать Drag and Drop или комбинацию клавиш «Вырезать»/«Вставить».

        Для последующих домашних заданий этого курса вам нужно создавать корневой пакет, иначе работа не будет принята.

        Создание класса товара
        Создайте в пакете org.skypro.skyshop.product класс товара Product, который будет содержать два значения:
            * название продукта в виде строки,
            * стоимость продукта в виде целого числа.
        Эти значения должны быть немодифицируемыми после создания объекта, но должна быть возможность получить эти
        значения в других классах.

        Подсказка
        Если значения должны быть немодифицируемыми — это значит, что в нашем классе должен быть единственный конструктор,
        принимающий эти значения. Сами поля должны иметь модификатор private, а доступ к ним должен осуществляться с помощью геттеров.

        Создание класса корзины для товаров
        Создайте простой класс корзины ProductBasket в пакете org.skypro.skyshop.basket.
        Этот класс содержит в себе одну корзину с продуктами, которые купил один пользователь. Вам нужно реализовать следующие публичные методы:
            * Метод добавления продукта в корзину: метод принимает в себя продукт и ничего не возвращает.
            * Метод получения общей стоимости корзины: метод ничего не принимает и возвращает целое число.
            * Метод, который печатает содержимое корзины: метод ничего не принимает и не возвращает, но печатает в консоль сообщение вида:
                <имя продукта>: <стоимость>
                <имя продукта>: <стоимость>
                <имя продукта>: <стоимость>
                Итого: <общая стоимость корзины>
        Если в корзине ничего нет, нужно напечатать фразу «в корзине пусто».
            * Метод, проверяющий продукт в корзине по имени: метод принимает в себя строку имени и возвращает Boolean
              в зависимости от того, есть продукт в корзине или его нет.
            * Метод очистки корзины: метод ничего не принимает и очищает массив, проставляя всем его элементам null.

        Обратите внимание!
            1. В качестве хранилища для объектов product используйте массив из пяти элементов, однако прямой доступ
               к этому массиву должен быть невозможен.
            2. Если в массиве не хватает места на следующий продукт, то метод добавления продукта должен выводить
               в консоль сообщение вида: «Невозможно добавить продукт».

        Демонстрация классов
        Создайте в классе App в методе main несколько продуктов и продемонстрируйте работу всех методов корзины по следующему сценарию:
            1. Добавление продукта в корзину.
            2. Добавление продукта в заполненную корзину, в которой нет свободного места.
            3. Печать содержимого корзины с несколькими товарами.
            4. Получение стоимости корзины с несколькими товарами.
            5. Поиск товара, который есть в корзине.
            6. Поиск товара, которого нет в корзине.
            7. Очистка корзины.
            8. Печать содержимого пустой корзины.
            9. Получение стоимости пустой корзины.
            10. Поиск товара по имени в пустой корзине.

        Рекомендации по выполнению работы
            1. Используйте модификатор static только в методе main, а модификатор public — только для методов и конструкторов.
            2. Для демонстрации классов можно создать несколько корзин.

ЗАДАЧА  2. ООП: наследование, абстрактные классы

                Описание структуры
        Интернет-магазин начинает поддерживать новые типы товаров, а значит, нужно расширить модель классов,
        чтобы поддерживать эти типы. Для этого:
            •	создадим классы для товаров со скидкой и товаров с фиксированной ценой,
            •	поменяем вывод данных в корзине,
            •	добавим новые методы для товаров и корзины.

        Выполняйте задание строго по порядку. Пока не сделали предыдущий шаг — не приступайте к следующему.

        1. Выделение корня иерархии
        Чтобы поддерживать новые типы товаров, нужно создать иерархию наследования для них.
            •	Сделайте класс Product  абстрактным и уберите из него поле цены.
            •	Так как цены у нас нет, метод getPrice() тоже должен стать абстрактным.
            •	Класс Product станет новым корнем иерархии, от него будем наследовать специфические классы товаров.

        Обратите внимание!
        После этого шага проект не будет компилироваться и запускаться. Так как в методе main класса App мы создаем
        товары через оператор new, а абстрактные классы создавать через оператор new нельзя.

        2. Создание класса обычного товара
            •	Восстановите функциональность кода: сделайте класс SimpleProduct, который наследуется от Product
                и принимает в свой конструктор (кроме имени) обычную цену товара, а переопределенный метод
                getPrice возвращает эту цену.
            •	Когда вы замените классом SimpleProduct класс Product в методе main, то получите полностью рабочий проект,
                в котором работает демонстрация.

        Обратите внимание! Класс корзины на этом этапе менять нельзя, и это не должно потребоваться.
        Если класс корзины не компилируется или какие-то методы в нем показывают ошибку, это значит, что вы
        неправильно выделили абстрактный класс или пропустили какой-то шаг.

        3. Создание класса товара со скидкой
            •	Расширим иерархию классов. Для этого сделайте класс товара со скидкой DiscountedProduct.
                Этот класс нужно унаследовать от Product.
            •	В этом классе создайте два поля — «базовая цена» и «скидка в целых процентах».
                Скидка может быть только положительным целым числом от 0 до 100. Проверку на это не нужно делать,
                достаточно просто учитывать при написании методов.
            •	Переопределите метод getPrice так, чтобы он учитывал скидку, которую вы применили к товару.

        4. Создание класса товара с фиксированной ценой
        В нашем интернет-магазине есть типы товаров с фиксированной ценой — fix price.
        Цена назначается один раз в год, поэтому в данный момент ее выгоднее установить в коде, используя константу.
            •	Создайте класс FixPriceProduct, конструктор которого принимает только имя продукта,
                а метод getPrice возвращает некоторую фиксированную цену.
            •	Саму фиксированную цену нужно оформить в виде приватной константы в классе FixPriceProduct.

        Константы в Java — это static- и final-переменные в классе. Имена констант используют специальный вид
        написания под названием SCREAMING_SNAKE_CASE.
        Если какое-то значение постоянно повторяется в программе, вы можете сохранить его в константе и использовать
        константу вместо непосредственного значения.

                // Пример объявления константы
                private static final String USER_GREETING = "Hello user!";

                // Пример константы в классе java.lang.Math, она выделена для понимания,
                // что последовательность цифр 3.14159265358979323846 — это число пи
                public static final double PI = 3.14159265358979323846;

        5. Изменение вывода корзины в классе ProductBacket
            •	Измените метод вывода, который печатает содержимое корзины, чтобы результат выводился в следующем виде:

                <имя продукта>: <стоимость>
                <имя продукта со скидкой>: <стоимость> (<скидка>%)
                <имя продукта c фиксированной ценой>: Фиксированная цена <значение константы фиксированной цены>
                Итого: <общая стоимость корзины>
                Специальных товаров: <Количество специальных товаров>
                Специальный товар — это товар со скидкой или фиксированной стоимостью.

        Чтобы правильно написать данный метод, вам нужно:
            •	переопределить метод toString в классах товаров так, чтобы вызов toString у товара выводил строку
                нужного формата (как на примере выше).

        Для подсчета количества специальных товаров:
            •	добавьте в абстрактный класс товара метод isSpecial, который возвращает true или false и
                переопределяет его в других классах товаров.

        Обратите внимание! В этом задании нельзя использовать оператор instanceof или другие методы,
        которые определяют класс товара. Используйте переопределение методов или вводите новые методы.

        6. Проверка изменений
            1.	Создайте в методе main несколько товаров специальных типов вместо SimpleProduct.
            2.	Проверьте, что все методы выводят правильные значения.
            3.	Убедитесь, что метод печати содержимого корзины выводит результат в нужной форме.

ЗАДАЧА  3. ООП: полиморфизм, интерфейсы. Поиск товаров и описания.

        Что нужно будет сделать
        В этой домашней работе мы добавим в приложение интернет-магазина новую сущность и сделаем движок для поиска по товарам.

        Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашку. За основу возьмите результат вашей работы по наследованию.

        1. Создание новой сущности
        Наш интернет-магазин растет, и мы решили добавить в объектную модель статьи о товарах.
        Для этого создайте класс Article, который будет немодифицируемым, как и класс товара, и будет содержать такой набор полей:
            •	название статьи в виде строки,
            •	текст статьи в виде строки.

        Добавьте в класс метод toString, который будет преобразовывать статью в строку такого вида:
            Название статьи
            Текст статьи

        Подсказка
        Класс нужно определить в один из существующих пакетов или создать новый. Подумайте, какой вариант лучше подойдет для этой задачи.

        2. Добавление функциональности поиска
        Чтобы была возможность искать и по статьям, и по товарам, нам нужно объединить их по какому-то признаку.
        Общий родительский класс тут не очень подходит, поэтому для реализации поиска понадобится интерфейс, который будет реализовывать статьи и товары.
            1.	Создайте интерфейс Searchable, который будет иметь три метода:
                •	Метод получения search term (термина поиска) — метод, который будет возвращать текст, по которому мы будем искать.
                •	Метод получения типа контента, который мы нашли. Метод должен возвращать строку с названием типа контента.
                •	Метод получения имени Searchable-объекта.

        Метод преобразования Searchable-объекта в строку (он не может называться toString, так как toString мы используем
        для вывода товаров в корзине) лучше назвать getStringRepresentation(). Стоит сделать этот метод интерфейса default
        и добавить реализацию, которая будет выводить строку вида: «имя Searchable-объекта — тип Searchable-объекта».
        Также не забывайте про правильный пакет.
            2.	Реализуйте интерфейс Searchable в классах товаров и статей. Для этого:
                •	В классе товаров нужно имплементировать интерфейс Searchable в родительском классе товаров и в
                    качестве search term — «возвращать имя товара», а в качестве типа — возвращать строку PRODUCT.
                •	В классе статьи в качестве search term нужно вернуть строку, состоящую из названия и текста статьи.
                    Можно просто возвращать строку из toString, в качестве типа возвращаем строку ARTICLE.

        3. Добавление компонента поиска
        Теперь у нас есть классы, поддерживающие поиск. Нам нужен класс, который будет искать введенную строку среди
        наших товаров и статей и показывать максимум 5 подходящих результатов пользователю.
        Для этого реализуйте класс SearchEngine, который состоит из следующих элементов.
            1.	Поле Searchable[] — массив всех элементов, по которым можно искать. Размерность массива нужно передавать через конструктор класса SearchEngine
            2.	Метод search — принимает в себя строку для поиска и возвращает 5 результатов поиска по массиву Searchable в виде массива из 5 элементов.
            3.	Метод add() — добавляет новый объект типа Searchable в массив поискового движка.

        Обратите внимание! Чтобы реализовать поиск по массиву Searchable, нужно перебрать весь массив: брать у каждого
        элемента SearchTerm и искать по нему, используя встроенный метод строки contains. Найденные элементы нужно сразу определять в массив.

        Если элементов больше 5, то можно прерывать цикл поиска с помощью ключевого слова break. Массив результатов может
        содержать null-элементы, а также его не нужно сортировать или вставлять элементы специальным образом через индексы,
        достаточно вернуть 5 первых подходящих объектов Searchable

        4. Тестирование изменений
        Теперь нам нужно продемонстрировать и протестировать изменения. Для этого:
            •	Создайте один объект типа SearchEngine  и добавьте в него все товары, которые создаются для проверки других методов.
            •	Создайте несколько объектов типа Article и добавьте их в Search Engine.
            •	Продемонстрируйте функциональность поиска с помощью объекта SearchEngine: вызовите метод search несколько раз с разными строками поиска.

        Подсказка
        Найденные объекты можно выводить с помощью System.out.println и статического метода класса Arrays → Arrays.toString(arr).

ЗАДАЧА  4. ООП: Исключения в Java

        Что нужно сделать
        В этой домашней работе вы продолжите работу над проектом интернет-магазина. На этот раз вам нужно будет:
            •	реализовать проверки полей для создания товаров и статей, чтобы не было возможности создавать неправильные объекты,
            •	расширить функциональность поиска по товарам и статьям.

        Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу.

        1. Реализация проверок в конструкторе класса Product
        Так как все классы наших продуктов унаследованы от Product, мы можем реализовать проверку данных только в нем.
        В конструкторе класса Product реализуйте проверку названия по следующим условиям:
            1.	Название продукта не может быть пустой строкой или null. При этом пустая строка может быть также строкой,
            состоящей только из пробелов: в этом случае правило не выполняется, так как это неправильное название для продукта.

        Подсказка
        Чтобы проверить, что строка не пустая и не состоит только из пробельных символов, можно использовать метод isBlank() класса String.

            2.	В конструкторе класса SimpleProduct реализуйте проверку передаваемой цены продукта, цена должна быть строго больше 0.
                Слово «строго» означает, что цена не включает в себя ноль, то есть должна быть 1 или выше.
            3.	В конструкторе класса DiscountedProduct реализуйте проверки базовой цены и процента скидки. Правила для базовой цены —
                такие же, как для цены в классе SimpleProduct. Правила для процента скидки — процент должен быть числом в
                диапазоне от 0 до 100 включительно. Слово «включительно» означает, что границы диапазона 0 и 100 тоже являются правильными значениями.

        Проверки по этим условиям нужно добавить в конструкторы классов. Если условия не выполняются, вам нужно выбросить
        IllegalArgumentException с сообщением, в котором раскрыты детали о том, какое правило не сработало.

        2. Демонстрация проверки данных в классе main
            •	Создайте несколько продуктов и нарочно заполните их поля неправильно.
            •	Затем обработайте IllegalArgumentException в блоках try и catch.
            •	В качестве обработки можно просто выводить сообщение из исключения.

        3. Реализация метода поиска самого подходящего элемента
            •	Реализуйте в классе SearchEngine метод, который находит среди объектов Searchable наиболее подходящий к поисковой строке и возвращает его.
            •	Метод должен принимать строку search, а возвращать объект Searchable.
        Наиболее подходящим назовем объект типа Searchable. Его метод getSearchTerm() содержит максимальное количество повторов строки search.
        Если таких объектов несколько, то вернуть можно любой из них.

        Подсказка
        Чтобы найти максимальное количество повторений подстроки в строке, можно воспользоваться следующим алгоритмом.
            //Алгоритм написан псевдокодом, и его идея в том, чтобы, используя операцию поиска индекса подстроки в строке посчитать количество
            //Операция indexOf(substring, индекс) ищет первый подходящий индекс подстроки, начиная с индекса "индекс".
            //Если она находит что-то, то индекс перемещается на длину подстроки и операция повторяется
            //до тех пора, пока в оставшей строке нет больше вхождений нашей подстроки
                str = "helloabcdehellonnnnnnhello"
                substring = "hello"
                количество = 0
                индекс = 0
                индексПодстроки = str.indexOf(substring, индекс)

            while(индексПодстроки != -1){
                количество++;
                индекс = индексПодстроки + substring.length();
	            индексПодстроки = str.indexOf(substring, индекс)
            }

        4. Добавление исключений
        Мы не хотим, чтобы метод поиска наиболее подходящего объекта возвращал null, если такого объекта нет.
        Поэтому если объект не найден, вам нужно выбрасывать собственное исключение — назовите его BestResultNotFound.
        Это исключение должно быть проверяемым, и в сообщении должно содержать информацию, для какого поискового запроса не нашлось подходящей статьи.

        5. Демонстрация нового метода поиска
        Продемонстрируйте в методе main новый метод поиска в двух сценариях:
            •	когда нужный объект существует,
            •	когда метод выбрасывает исключение.
        Обработайте исключение и выведите сообщения об ошибке.

ЗАДАЧА  5. ООП: Java Collections Framework: List

        В этой домашней работе вы научитесь поддерживать условно-нефиксированное количество элементов в продуктовой корзине и поисковом движке.
        Для этого вам нужно:
            •	поменять используемые структуры данных в классах SearchEngine и ProductBasket на списки,
            •	добавить метод удаления продукта из корзины по имени.

        Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу.

        1. Изменение используемой структуры данных в классе ProductBacket
            •	Поменяйте используемую структуру данных в классе ProductBacket с массива на список. Тип списка выберите самостоятельно.
                Учитывайте, что мы не обращаемся к элементам корзины по индексам, а только добавляем и удаляем элементы, не используя их индексы.
            •	После этого список станет условно-нефиксированным. Удалите код, который выводил сообщение “Невозможно добавить продукт”, а также связанную с ним демонстрацию в методе main.
            •	Убедитесь, что демонстрация в методе main  работает без дополнительных изменений, так как мы меняем только внутреннюю реализацию структуру данных внутри корзины.

        2. Добавление метода удаления продукта по имени из корзины
        Теперь добавьте метод, который по переданному имени продукта удаляет все продукты с таким именем из корзины:
            •	Метод должен принимать строку name и возвращать список (List) удаленных продуктов.
            •	Если продукта нет в корзине, то возвращаемый список должен быть пустым.

        Подсказка
        Для удаления элементов списка используйте итератор.

        Продемонстрируйте в методе main данный метод по сценарию:
            1.	Удалить существующий продукт из корзины.
            2.	Вывести удаленные продукты на экран.
            3.	Вывести содержимое корзины с помощью метода printBacket.
            4.	Удалить несуществующий продукт.
            5.	Проверить, что список удаленных продуктов пустой и вывести сообщение “Список пуст”.
            6.	Вывести содержимое корзины на экран.

        3. Изменение используемой структуры данных в классе SearchEngine
            •	В классе SearchEngine поменяйте структуру данных с массива на список.
            •	Измените метод поиска: он должен возвращать *все* подходящие результаты (а не 5 результатов, как раньше).

        После выполнения предыдущих шагов исправьте демонстрацию в методе main так, чтобы она работала со списком результатов поиска (вместо массива).

ЗАДАЧА  6. ООП: Java Collections Framework: Map

        В этой домашней работе вы снова поработаете со структурами данных в классе продуктовой корзины и поискового движка и замените их на мапы.
        1.	В нашей реализации ProductBasket есть несколько методов, которые выбирают или удаляют товар по имени.
            Каждый раз нам приходится перебирать весь список товаров в корзине. Попробуем оптимизировать процесс и изменить структуру данных в корзине.
        2.	Чтобы результаты возвращались отсортированными по имени, изменим выдачу результатов поиска в приложении интернет-магазина.

        Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу.

        1. Модификация структуры данных в корзине
        Вам нужно заменить список, используемый в продуктовой корзине, на Map
        Ключом будет имя, а значением — список продуктов (поскольку продукты с одним и тем же именем могут быть добавлены несколько раз).
        Тип Map выберите самостоятельно с учетом того, что у нас есть несколько операций получения продуктов по имени.

        Сложность может возникнуть с методами перебора всех продуктов, например с методом печати содержимого корзины.
        Чтобы правильно перебрать все продукты, возьмите все значения из Map и далее каждый из них дополнительно переберите вложенным циклом.

        После замены структуры и переделки методов скомпилируйте и запустите проект. Изменения в работе и новые ошибки не должны возникнуть.
        Дополнительные изменения в main также не нужны.

        2. Модификация возвращаемого значения в методе поиска
        В классе поискового движка вам нужно модифицировать метод поиска таким образом, чтобы он возвращал отсортированную по именам мапу:
            •	с ключом — именем Searchable-объекта
            •	и значением — самим Searchable-объектом.
        После этого перепишите код в методе main, который работает с выводом результатов поиска.

ЗАДАЧА  7. ООП: Java Collections Framework: Set

        В этой домашней работе вам предстоит поработать над поиском в приложении интернет-магазина, изменить класс SearchEngine
        и избавиться от возможности добавления туда дубликатов.

        Задание 1

        Сейчас наш класс поискового движка позволяет добавлять в себя дубликаты. Это значит, что время поиска подходящего товара
        или статьи может занимать много времени. Поэтому уберем возможность добавления дубликатов в класс SearchEngine.

        Для этого нужно применить Set, а так же написать реализацию методов equals и hashCode для классов, которые добавляются
        в SearchEngine — абстрактного класса Product и класса Article.

        Продуктовая команда решила, что продуктов и статей с одинаковым именем не должно существовать. Значит, в качестве
        ключа hashCode и элемента для сравнения мы можем выбрать поле с именем объекта.

        Шаг 1. Замена List на Set.
        Для начала заменим структуру List на структуру Set.
            •	Для этого достаточно использовать HashSet, так как отсортированности и сохранения порядка добавления не требуется.
            •	После замены структуры и небольших исправлений проект должен работать так же, как и раньше.

        Шаг 2. Реализация equals и hashCode для статей и продуктов
        Реализуйте в классе статей и в классе продуктов методы equals и hashCode, которые учитывают только имя статьи или продукта. Остальные поля пока учитывать не нужно.

        Попробуйте написать методы вручную, чтобы потренироваться. Также можно воспользоваться автогенерацией методов в IDEA.

        Задание 2

        Продуктовой команде не понравилась сортировка результатов поиска по имени с помощью натурального сравнения, а также то,
        что результаты поиска теперь выводятся с именем, что не очень красиво, так как в Searchable уже есть вывод имени.

        Перепишите тип выдачи результатов поиска.
            •	На этот раз будем выдавать отсортированный Set из Searchable-элементов.
            •	Сортировку сделаем в следующем порядке: от самого длинного названия (в начале) до самого короткого (в конце).
            •	Если длина названий одинаковая, то сортировать будем в натуральном порядке.

        Шаг 1. Замена TreeMap на TreeSet
        Вам нужно заменить TreeMap, который вы возвращали при выводе результатов поиска на TreeSet и переписать все остальные методы так, чтобы проект компилировался.
        Однако если вы запустите проект на данном этапе, то получите ошибку ClassCastException, так как классы, которые добавляются в поисковый движок, не реализуют интерфейс Comparable.

        Шаг 2. Компаратор
        Теперь нужно реализовать сортировку статей согласно условиям:
            •	Статьи в результатах поиска должны выводиться, начиная от статьи с самым длинным именем и заканчивая статьей с самым коротким именем.
            •	Если длина имен одинаковая, то статьи должны сортироваться в натуральном порядке.
        Для этого вам понадобиться написать компаратор, который состоит из двух частей:
            1.	Получение длины имен и сравнение их через Integer.compare.
            2.	Если значение, которое вернул Integer.compare == 0, тогда нужно сравнивать имена, используя методы compareTo.
        Результат, который возвращает наш компаратор, — это либо результат Integer.compare (если он не 0), либо результат сравнения имен через compareTo.
        Проверьте, что результаты поиска сортируются в соответствии с этим компаратором. Попробуйте разные сценарии с разными результатами.

ЗАДАЧА  8. ООП: Stream API и лямбда-выражения

        В этой домашней работе мы перепишем основные методы продуктовой корзины и поискового движка на Stream API.

        1. Измените метод search в поисковом движке
          Метод search не должен использовать циклы — перепишите его одним стримом с использованием промежуточной операции filter и терминальной операции collect.
          Так как результаты поиска мы возвращаем в виде TreeSet с собственным компаратором, то нужно использовать специальный
        коллектор Collectors.toCollection(() → ). Он принимает в себя функциональный интерфейс Supplier<Collection>, который создает нужную нам коллекцию.
          Для этого напишите лямбда-выражение, которое реализует Supplier и возвращает нужный нам TreeSet с компаратором.
        В остальном цепочка будет похожа на изученную ранее цепочку filter().collect().
          После этого изменения проект должен компилироваться и иметь тот же самый вывод, что и до изменения.

        2. Измените методы в классе ProductBasket
          В классах корзины вам нужно заменить циклы на StreamAPI. Сложность в том, что корзина хранит товары в виде Map<String, List<Product>>.
        Чтобы получить доступ к списку товаров, приходилось использовать вложенный цикл.
          В StreamAPI для этого есть операция flatMap, которая превращает Stream из списков в плоский Stream, который содержит
        все продукты products.values().stream().flatMap(Collection::stream)
          После применения flatMap можно выполнять любые операции над продуктами так, как если бы они лежали в одном списке.
        Рекомендации по переписыванию методов:
            1.	Метод, который возвращает полную стоимость корзины, нужно переписать используя операторы mapToInt и sum.
            2.	Метод печати корзины нужно переписать, используя метод forEach. Если в этом же методе вы считаете количество специальных продуктов, нужно выделить его в отдельный приватный метод getSpecialCount, который использует операции filter и count.

        После этих изменений:
        •	код должен компилироваться,
        •	вывод — остаться таким же, как до изменений.
       */
}